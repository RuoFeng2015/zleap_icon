<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>zleap-icon å›¾æ ‡åŒæ­¥</title>
  <style>
    :root {
      --primary: #007AFF;
      --primary-gradient: linear-gradient(135deg, #007AFF, #00C6FF);
      --success: #34C759;
      --danger: #FF3B30;
      --bg-glass: rgba(255, 255, 255, 0.65);
      --border-glass: rgba(255, 255, 255, 0.5);
      --shadow-glass: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
      --blur: 20px;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Text', 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
      font-size: 13px;
      color: #1d1d1f;
      /* Clean, Fresh iOS-style Aurora Background */
      background-color: #f5f5f7;
      background-image:
        radial-gradient(circle at 10% 20%, rgba(69, 168, 250, 0.15) 0%, transparent 40%),
        radial-gradient(circle at 90% 10%, rgba(118, 75, 162, 0.1) 0%, transparent 40%),
        radial-gradient(circle at 80% 80%, rgba(88, 203, 255, 0.15) 0%, transparent 40%),
        radial-gradient(circle at 20% 80%, rgba(255, 255, 255, 0.9) 0%, transparent 40%);
      background-attachment: fixed;
      background-size: 120% 120%;
      animation: aurora 15s ease infinite alternate;
      padding: 16px;
      min-height: 100vh;
    }

    @keyframes aurora {
      0% {
        background-position: 0% 0%;
      }

      100% {
        background-position: 100% 100%;
      }
    }

    /* Glass Container */
    .glass-panel {
      background: var(--bg-glass);
      backdrop-filter: blur(var(--blur));
      -webkit-backdrop-filter: blur(var(--blur));
      border: 1px solid var(--border-glass);
      box-shadow: var(--shadow-glass);
      border-radius: 16px;
      padding: 16px;
      margin-bottom: 16px;
      transition: transform 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .container {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    /* Tabs - Segmented Control Style */
    .tabs {
      background: rgba(118, 118, 128, 0.12);
      border-radius: 8px;
      padding: 2px;
      display: flex;
      margin-bottom: 16px;
      border: none;
    }

    .tab {
      flex: 1;
      text-align: center;
      padding: 6px 12px;
      font-size: 13px;
      font-weight: 500;
      color: #636366;
      border-radius: 6px;
      border: none;
      background: transparent;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .tab.active {
      background: #fff;
      color: #000;
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.12), 0 3px 1px rgba(0, 0, 0, 0.04);
    }

    .tab:hover:not(.active) {
      background: rgba(255, 255, 255, 0.5);
    }

    .tab-content {
      display: none;
      animation: fadeIn 0.3s ease;
    }

    .tab-content.active {
      display: block;
    }

    /* Form Elements */
    .form-group {
      margin-bottom: 16px;
    }

    label {
      display: block;
      margin-bottom: 6px;
      font-weight: 600;
      font-size: 12px;
      color: #86868b;
      text-transform: uppercase;
      letter-spacing: 0.02em;
    }

    .label-hint {
      text-transform: none;
      font-weight: 400;
      opacity: 0.8;
    }

    input[type="text"],
    input[type="password"],
    textarea,
    select {
      width: 100%;
      padding: 10px 12px;
      background: rgba(255, 255, 255, 0.5);
      border: 1px solid rgba(0, 0, 0, 0.1);
      border-radius: 10px;
      font-size: 13px;
      color: #1d1d1f;
      transition: all 0.2s;
      outline: none;
      backdrop-filter: blur(5px);
    }

    input:focus,
    textarea:focus,
    select:focus {
      background: #fff;
      border-color: var(--primary);
      box-shadow: 0 0 0 4px rgba(0, 122, 255, 0.15);
    }

    select {
      padding-right: 32px;
      appearance: none;
      -webkit-appearance: none;
      background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23333' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 8px center;
      background-size: 16px;
    }

    textarea {
      min-height: 80px;
      resize: vertical;
    }

    /* Buttons */
    .btn {
      width: 100%;
      padding: 12px;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .btn:active {
      transform: scale(0.96);
    }

    .btn-primary {
      background: var(--primary-gradient);
      color: white;
      box-shadow: 0 4px 15px rgba(0, 122, 255, 0.3);
    }

    .btn-primary:hover {
      box-shadow: 0 6px 20px rgba(0, 122, 255, 0.4);
      filter: brightness(1.05);
    }

    .btn-secondary {
      background: rgba(255, 255, 255, 0.8);
      color: #007AFF;
      border: 1px solid rgba(0, 122, 255, 0.1);
    }

    /* Summary Card */
    .summary {
      background: rgba(255, 255, 255, 0.5);
      border-radius: 12px;
      padding: 12px;
      margin-bottom: 16px;
      font-size: 12px;
    }

    .summary-item {
      display: flex;
      justify-content: space-between;
      padding: 6px 0;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }

    .summary-item:last-child {
      border-bottom: none;
    }

    .summary-item span:first-child {
      color: #86868b;
    }

    .summary-item span:last-child {
      font-weight: 600;
      color: #1d1d1f;
    }

    /* Status & Alerts */
    .status {
      padding: 12px;
      border-radius: 12px;
      font-size: 12px;
      margin-top: 16px;
      background: rgba(255, 255, 255, 0.8);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(0, 0, 0, 0.05);
    }

    .status-success {
      background: rgba(52, 199, 89, 0.1);
      color: #248a3d;
      border-color: rgba(52, 199, 89, 0.2);
    }

    .status-error {
      background: rgba(255, 59, 48, 0.1);
      color: #d70015;
      border-color: rgba(255, 59, 48, 0.2);
    }

    .status-info {
      background: rgba(0, 122, 255, 0.1);
      color: #0040dd;
      border-color: rgba(0, 122, 255, 0.2);
    }

    /* Modern Progress Bar */
    .progress-container {
      margin-top: 20px;
      text-align: center;
    }

    .progress-track {
      width: 100%;
      height: 12px;
      background: rgba(0, 0, 0, 0.05);
      border-radius: 10px;
      overflow: hidden;
      margin-bottom: 8px;
      position: relative;
    }

    .progress-fill {
      height: 100%;
      background: var(--primary-gradient);
      width: 0%;
      border-radius: 10px;
      transition: width 0.4s cubic-bezier(0.25, 1, 0.5, 1);
      /* Shimmer Effect */
      position: relative;
    }

    .progress-fill::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      bottom: 0;
      right: 0;
      background-image: linear-gradient(-45deg,
          rgba(255, 255, 255, 0.2) 25%,
          transparent 25%,
          transparent 50%,
          rgba(255, 255, 255, 0.2) 50%,
          rgba(255, 255, 255, 0.2) 75%,
          transparent 75%,
          transparent);
      background-size: 20px 20px;
      animation: moveStripes 1s linear infinite;
    }

    @keyframes moveStripes {
      0% {
        background-position: 0 0;
      }

      100% {
        background-position: 20px 20px;
      }
    }

    .progress-text {
      font-size: 11px;
      color: #86868b;
      font-weight: 500;
    }

    /* Success Animation */
    .success-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.9);
      backdrop-filter: blur(20px);
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.5s ease;
    }

    .success-overlay.visible {
      opacity: 1;
      pointer-events: auto;
    }

    .checkmark-circle {
      width: 80px;
      height: 80px;
      position: relative;
    }

    .checkmark-circle svg {
      width: 100%;
      height: 100%;
    }

    .checkmark-circle path {
      stroke-dasharray: 166;
      stroke-dashoffset: 166;
      stroke-width: 4;
      stroke: #34C759;
      fill: none;
      animation: stroke 0.6s cubic-bezier(0.65, 0, 0.45, 1) forwards 0.2s;
    }

    .checkmark-circle circle {
      stroke-dasharray: 251;
      /* 2 * PI * 40 */
      stroke-dashoffset: 251;
      animation: stroke 0.6s cubic-bezier(0.65, 0, 0.45, 1) forwards;
    }

    @keyframes stroke {
      100% {
        stroke-dashoffset: 0;
      }
    }

    .success-text {
      margin-top: 20px;
      font-size: 18px;
      font-weight: 700;
      color: #1d1d1f;
      transform: translateY(20px);
      opacity: 0;
      transition: all 0.5s ease 0.5s;
    }

    .success-subtext {
      margin-top: 8px;
      font-size: 13px;
      color: #86868b;
      transform: translateY(20px);
      opacity: 0;
      transition: all 0.5s ease 0.6s;
    }

    .success-overlay.visible .success-text,
    .success-overlay.visible .success-subtext {
      transform: translateY(0);
      opacity: 1;
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    /* Icon List */
    .icon-list {
      max-height: 200px;
      overflow-y: auto;
      background: rgba(255, 255, 255, 0.4);
      border: 1px solid rgba(0, 0, 0, 0.05);
      border-radius: 8px;
      margin-top: 8px;
    }

    .icon-list::-webkit-scrollbar {
      width: 6px;
    }

    .icon-list::-webkit-scrollbar-track {
      background: transparent;
    }

    .icon-list::-webkit-scrollbar-thumb {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 3px;
    }

    .icon-item {
      padding: 8px 12px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
    }

    .icon-item:last-child {
      border-bottom: none;
    }

    .icon-name {
      font-weight: 500;
      color: #333;
    }

    .icon-size {
      color: #86868b;
      font-size: 11px;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>

<body>
  <div class="container">
    <!-- Tabs -->
    <div class="tabs">
      <button class="tab active" data-tab="sync">åŒæ­¥</button>
      <button class="tab" data-tab="config">è®¾ç½®</button>
    </div>

    <!-- Sync Tab -->
    <div id="sync-tab" class="tab-content active">
      <div id="not-configured" class="status status-info">
        è¯·å…ˆé…ç½® GitHub è®¾ç½®
        <button class="btn btn-secondary" style="margin-top: 8px;" onclick="switchTab('config')">
          å‰å¾€è®¾ç½®
        </button>
      </div>

      <div id="sync-form" class="hidden glass-panel">
        <div class="summary">
          <div class="summary-item">
            <span>ä»“åº“åœ°å€ï¼š</span>
            <span id="display-repo">-</span>
          </div>
          <div class="summary-item">
            <span>åŒæ­¥èŒƒå›´ï¼š</span>
            <span id="display-selection">æ•´ä¸ªé¡µé¢</span>
          </div>
          <div class="summary-item">
            <span>å‘ç°å›¾æ ‡ï¼š</span>
            <span id="display-icon-count">-</span>
          </div>
        </div>

        <div id="selection-hint" class="status status-info" style="margin-bottom: 12px;">
          ğŸ’¡ æç¤ºï¼šé€‰ä¸­ä¸€ä¸ª Frame å¯ä»¥åªåŒæ­¥è¯¥åŒºåŸŸå†…çš„å›¾æ ‡
        </div>

        <div class="form-group">
          <label>åŒæ­¥æ¨¡å¼</label>
          <select id="sync-mode">
            <option value="incremental">å¢é‡æ›´æ–°ï¼ˆä¿ç•™ç°æœ‰å›¾æ ‡ï¼Œåªæ·»åŠ /æ›´æ–°é€‰ä¸­çš„å›¾æ ‡ï¼‰</option>
            <option value="replace">å…¨é‡è¦†ç›–ï¼ˆåˆ é™¤æ‰€æœ‰æ—§å›¾æ ‡ï¼Œåªä¿ç•™æœ¬æ¬¡ä¸Šä¼ çš„å›¾æ ‡ï¼‰</option>
          </select>
        </div>

        <div class="form-group">
          <label>ç‰ˆæœ¬å· <span class="label-hint">ï¼ˆå¦‚ 1.2.0ï¼‰</span></label>
          <input type="text" id="version" placeholder="1.0.0" pattern="^\d+\.\d+\.\d+$">
        </div>

        <div class="form-group">
          <label>æ›´æ–°è¯´æ˜</label>
          <textarea id="message" placeholder="æè¿°æœ¬æ¬¡æ›´æ–°çš„å†…å®¹..."></textarea>
        </div>

        <button id="sync-btn" class="btn btn-primary btn-block" onclick="triggerSync()">
          åŒæ­¥å›¾æ ‡åˆ° GitHub
        </button>

        <div id="progress-container" class="progress-container hidden">
          <div class="progress-track">
            <div id="progress-fill" class="progress-fill"></div>
          </div>
          <div id="progress-text" class="progress-text">å‡†å¤‡ä¸­...</div>
        </div>

        <div id="sync-status" class="hidden"></div>

        <div class="form-group" style="margin-top: 16px;">
          <label>å½“å‰æ–‡ä»¶ä¸­çš„å›¾æ ‡ï¼š</label>
          <div id="icon-list" class="icon-list">
            <div class="icon-item">
              <span class="icon-name">åŠ è½½ä¸­...</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Config Tab -->
    <div id="config-tab" class="tab-content glass-panel">
      <div class="form-group">
        <label>GitHub ä»“åº“ <span class="label-hint">ï¼ˆç”¨æˆ·å/ä»“åº“åï¼‰</span></label>
        <input type="text" id="github-repo" placeholder="your-org/icon-library">
      </div>

      <div class="form-group">
        <label>GitHub Token <span class="label-hint">ï¼ˆä¸ªäººè®¿é—®ä»¤ç‰Œï¼‰</span></label>
        <input type="password" id="github-token" placeholder="ghp_xxxxxxxxxxxx">
        <div style="margin-top: 4px; font-size: 11px; color: #666;">
          Token éœ€è¦ <code>repo</code> æƒé™ã€‚
          <a href="https://github.com/settings/tokens/new" target="_blank">åˆ›å»º Token</a>
        </div>
      </div>

      <div class="form-group">
        <label>é»˜è®¤åˆ†æ”¯</label>
        <input type="text" id="default-branch" placeholder="main" value="main">
      </div>

      <button class="btn btn-primary btn-block" onclick="saveConfig()">
        ä¿å­˜è®¾ç½®
      </button>

      <div id="config-status" class="hidden"></div>

      <!-- Debug Log Container -->
      <div id="debug-log"
        style="margin-top: 12px; padding: 10px; background: #f8f8f8; border-radius: 8px; font-size: 11px; font-family: monospace; max-height: 150px; overflow-y: auto; display: none;">
        <div style="font-weight: bold; margin-bottom: 6px; color: #666;">ğŸ”§ è°ƒè¯•æ—¥å¿— <span id="debug-version"
            style="font-weight: normal; font-size: 10px; color: #999;"></span></div>
        <div id="debug-log-content" style="color: #333; line-height: 1.6;"></div>
      </div>
    </div>
  </div>

  <!-- Success Overlay -->
  <div id="success-overlay" class="success-overlay">
    <div class="checkmark-circle">
      <svg viewBox="0 0 80 80">
        <circle cx="40" cy="40" r="40" fill="none"></circle>
        <path d="M22 41L35 54L59 30"></path>
      </svg>
    </div>
    <div class="success-text">åŒæ­¥æˆåŠŸ!</div>
    <div class="success-subtext" id="success-detail">å·²ä¸Šä¼ å›¾æ ‡åˆ° GitHub</div>
    <button class="btn btn-primary" style="margin-top: 30px; width: auto; padding: 10px 30px;"
      onclick="closeSuccessOverlay()">
      å®Œæˆ
    </button>
  </div>

  <!-- Script starts here -->
  <script>
    // ============================================
    // Plugin Version
    // ============================================
    const PLUGIN_VERSION = '0.0.1';

    // ============================================
    // State
    // ============================================

    let currentConfig = null;
    let icons = [];
    let isSyncing = false;

    // Success Overlay Controls
    function showSuccessOverlay(title, detail) {
      const overlay = document.getElementById('success-overlay');
      if (title) overlay.querySelector('.success-text').textContent = title;
      if (detail) document.getElementById('success-detail').textContent = detail;
      overlay.classList.add('visible');
    }

    function closeSuccessOverlay() {
      document.getElementById('success-overlay').classList.remove('visible');
    }

    // ============================================
    // Tab Navigation
    // ============================================

    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        const tabName = tab.dataset.tab;
        switchTab(tabName);
      });
    });

    function switchTab(tabName) {
      document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));

      document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
      document.getElementById(`${tabName}-tab`).classList.add('active');
    }

    // ============================================
    // Plugin Communication
    // ============================================

    // Send message to plugin code
    function postMessage(type, payload) {
      parent.postMessage({ pluginMessage: { type, payload } }, '*');
    }

    // Receive messages from plugin code
    window.onmessage = async (event) => {
      const msg = event.data.pluginMessage;
      if (!msg) return;

      switch (msg.type) {
        case 'config-loaded':
          handleConfigLoaded(msg.payload);
          break;
        case 'icons-loaded':
          handleIconsLoaded(msg.payload);
          break;
        case 'selection-changed':
          handleSelectionChanged(msg.payload);
          break;
        case 'export-progress':
          handleExportProgress(msg.payload);
          break;
        case 'sync-result':
          await handleSyncResult(msg.payload);
          break;
        case 'error':
          if (typeof debugLog === 'function') {
            debugLog('æ”¶åˆ°é”™è¯¯: ' + msg.payload.message, 'error');
          }
          showError(msg.payload.message);
          break;
      }
    };

    // ============================================
    // Config Handlers
    // ============================================

    function handleConfigLoaded(config) {
      currentConfig = config;

      // Debug: show that we received a response from plugin
      if (typeof debugLog === 'function') {
        debugLog('æ”¶åˆ°æ’ä»¶å“åº”: config-loaded', 'success');
        debugLog(`é…ç½®çŠ¶æ€: repo=${config.githubRepo ? 'å·²è®¾ç½®' : 'ç©º'}, token=${config.githubToken ? 'å·²è®¾ç½®' : 'ç©º'}`);
      }

      // Update form fields
      document.getElementById('github-repo').value = config.githubRepo || '';
      document.getElementById('github-token').value = config.githubToken || '';
      document.getElementById('default-branch').value = config.defaultBranch || 'main';

      // Check if configured - both repo and token must be non-empty
      const isConfigured = !!(config.githubRepo && config.githubToken);

      console.log('é…ç½®å·²åŠ è½½:', {
        hasRepo: !!config.githubRepo,
        hasToken: !!config.githubToken,
        isConfigured
      });

      // Update sync tab visibility
      document.getElementById('not-configured').classList.toggle('hidden', isConfigured);
      document.getElementById('sync-form').classList.toggle('hidden', !isConfigured);

      if (isConfigured) {
        document.getElementById('display-repo').textContent = config.githubRepo;
        // Request icons
        postMessage('get-icons');

        // Fetch current version from GitHub
        fetchCurrentVersion(config.githubRepo, config.githubToken);

        // Show success message and switch to sync tab if we just saved
        if (document.querySelector('[data-tab="config"]').classList.contains('active')) {
          if (typeof debugLog === 'function') {
            debugLog('é…ç½®ä¿å­˜æˆåŠŸï¼å³å°†è·³è½¬åˆ°åŒæ­¥é¡µé¢', 'success');
          }
          showStatus('config-status', 'è®¾ç½®ä¿å­˜æˆåŠŸï¼ç°åœ¨å¯ä»¥åŒæ­¥å›¾æ ‡äº†ã€‚', 'success');
          // Auto switch to sync tab after a short delay
          setTimeout(() => switchTab('sync'), 1000);
        }
      }
    }

    // ============================================
    // Debug Logging (visible in UI)
    // ============================================

    function debugLog(message, type = 'info') {
      const container = document.getElementById('debug-log');
      const content = document.getElementById('debug-log-content');

      // Show the debug container and set version
      container.style.display = 'block';
      const versionSpan = document.getElementById('debug-version');
      if (versionSpan && !versionSpan.textContent) {
        versionSpan.textContent = `v${PLUGIN_VERSION}`;
      }

      // Get timestamp
      const now = new Date();
      const time = now.toLocaleTimeString('zh-CN', { hour12: false });

      // Color based on type
      let color = '#333';
      let prefix = 'ğŸ“';
      if (type === 'success') { color = '#34C759'; prefix = 'âœ…'; }
      if (type === 'error') { color = '#FF3B30'; prefix = 'âŒ'; }
      if (type === 'warn') { color = '#FF9500'; prefix = 'âš ï¸'; }

      // Add log line
      const line = document.createElement('div');
      line.style.color = color;
      line.innerHTML = `<span style="color: #999;">[${time}]</span> ${prefix} ${message}`;
      content.appendChild(line);

      // Auto scroll to bottom
      container.scrollTop = container.scrollHeight;

      // Also log to console
      console.log(`[DEBUG] ${message}`);
    }

    function clearDebugLog() {
      const content = document.getElementById('debug-log-content');
      content.innerHTML = '';
    }

    function saveConfig() {
      clearDebugLog();
      debugLog('saveConfig() è¢«è°ƒç”¨');

      const config = {
        githubRepo: document.getElementById('github-repo').value.trim(),
        githubToken: document.getElementById('github-token').value.trim(),
        defaultBranch: document.getElementById('default-branch').value.trim() || 'main'
      };

      debugLog(`é…ç½®ä¿¡æ¯: repo=${config.githubRepo}, token=${config.githubToken ? 'å·²å¡«å†™' : 'ç©º'}, branch=${config.defaultBranch}`);

      if (!config.githubRepo) {
        debugLog('éªŒè¯å¤±è´¥: æœªå¡«å†™ä»“åº“åœ°å€', 'error');
        showStatus('config-status', 'è¯·è¾“å…¥ GitHub ä»“åº“åœ°å€', 'error');
        return;
      }

      if (!config.githubToken) {
        debugLog('éªŒè¯å¤±è´¥: æœªå¡«å†™ Token', 'error');
        showStatus('config-status', 'è¯·è¾“å…¥ GitHub Token', 'error');
        return;
      }

      debugLog('éªŒè¯é€šè¿‡ï¼Œå‘é€æ¶ˆæ¯åˆ°æ’ä»¶ä¸»çº¿ç¨‹...');
      showStatus('config-status', 'æ­£åœ¨ä¿å­˜...', 'info');

      try {
        postMessage('save-config', config);
        debugLog('æ¶ˆæ¯å·²å‘é€ï¼Œç­‰å¾…æ’ä»¶å“åº”...', 'success');
      } catch (err) {
        debugLog('å‘é€æ¶ˆæ¯å¤±è´¥: ' + err.message, 'error');
      }
    }

    // ============================================
    // Icon Handlers
    // ============================================

    function handleIconsLoaded(data) {
      icons = data.icons;
      updateIconDisplay(data);
      // Generate default changelog (not selection based)
      generateDefaultChangelog(icons, false);
    }

    function handleSelectionChanged(data) {
      icons = data.icons;
      updateIconDisplay(data);

      // Generate default changelog (selection based)
      generateDefaultChangelog(icons, data.hasSelection);

      // æ›´æ–°é€‰åŒºæ˜¾ç¤º
      document.getElementById('display-selection').textContent = data.selectionName || 'æœªé€‰æ‹©';

      // æ˜¾ç¤º/éšè—é€‰åŒºæç¤º + å¤„ç† needsSelection
      const hintEl = document.getElementById('selection-hint');
      const syncBtn = document.getElementById('sync-btn');

      if (data.needsSelection) {
        // éœ€è¦ç”¨æˆ·å…ˆé€‰æ‹©åŒºåŸŸ
        hintEl.innerHTML = 'âš ï¸ è¯·å…ˆåœ¨ç”»å¸ƒä¸­é€‰æ‹©è¦åŒæ­¥çš„å›¾æ ‡åŒºåŸŸï¼ˆFrame æˆ– Componentï¼‰';
        hintEl.className = 'status status-info';
        hintEl.style.marginBottom = '12px';
        // ç¦ç”¨åŒæ­¥æŒ‰é’®
        syncBtn.disabled = true;
        syncBtn.style.opacity = '0.5';
        syncBtn.style.cursor = 'not-allowed';
      } else if (data.hasSelection) {
        hintEl.innerHTML = `âœ“ å·²é€‰ä¸­ <strong>${data.selectionName}</strong>ï¼Œå°†åªåŒæ­¥è¯¥åŒºåŸŸå†…çš„å›¾æ ‡`;
        hintEl.className = 'status status-success';
        hintEl.style.marginBottom = '12px';
        // å¯ç”¨åŒæ­¥æŒ‰é’®
        syncBtn.disabled = false;
        syncBtn.style.opacity = '1';
        syncBtn.style.cursor = 'pointer';
      } else {
        hintEl.innerHTML = 'ğŸ’¡ æç¤ºï¼šé€‰ä¸­ä¸€ä¸ª Frame å¯ä»¥åªåŒæ­¥è¯¥åŒºåŸŸå†…çš„å›¾æ ‡';
        hintEl.className = 'status status-info';
        hintEl.style.marginBottom = '12px';
        // ä¿æŒæŒ‰é’®çŠ¶æ€ï¼ˆæ— é€‰åŒºä½†ä¹Ÿæ²¡æœ‰ needsSelection æ—¶ï¼Œä»å¯åŒæ­¥æ•´ä¸ªé¡µé¢ï¼‰
        // å®é™…ä¸Šæˆ‘ä»¬ç§»é™¤äº†æ•´é¡µæ‰«æï¼Œæ‰€ä»¥è¿™ç§æƒ…å†µä¸ä¼šå‘ç”Ÿ
      }
    }

    function updateIconDisplay(data) {
      document.getElementById('display-icon-count').textContent = data.needsSelection ? '-' : data.totalCount;

      const listEl = document.getElementById('icon-list');
      if (data.needsSelection) {
        listEl.innerHTML = '<div class="icon-item"><span class="icon-name" style="color: #86868b;">è¯·é€‰æ‹©ä¸€ä¸ªåŒºåŸŸåæŸ¥çœ‹å›¾æ ‡</span></div>';
      } else if (icons.length === 0) {
        listEl.innerHTML = '<div class="icon-item"><span class="icon-name">é€‰ä¸­åŒºåŸŸå†…æœªæ‰¾åˆ°å›¾æ ‡</span></div>';
      } else {
        listEl.innerHTML = icons.map(icon => `
          <div class="icon-item">
            <span class="icon-name">${escapeHtml(icon.name)}</span>
            <span class="icon-size">${icon.width}Ã—${icon.height}</span>
          </div>
        `).join('');
      }
    }

    // ============================================
    // Progress Handler
    // ============================================

    function handleExportProgress(data) {
      const progressContainer = document.getElementById('progress-container');
      const progressFill = document.getElementById('progress-fill');
      const progressText = document.getElementById('progress-text');

      progressContainer.classList.remove('hidden');

      const percent = Math.round((data.current / data.total) * 100);
      progressFill.style.width = `${percent}%`;
      progressText.textContent = `å¯¼å‡ºä¸­: ${data.current}/${data.total} - ${data.currentName}`;
    }

    // ============================================
    // Sync Handlers
    // ============================================

    function triggerSync() {
      if (isSyncing) return;

      const version = document.getElementById('version').value.trim();
      const message = document.getElementById('message').value.trim();
      const syncMode = document.getElementById('sync-mode').value;

      if (!version) {
        showStatus('sync-status', 'è¯·è¾“å…¥ç‰ˆæœ¬å·', 'error');
        return;
      }

      if (!/^\d+\.\d+\.\d+$/.test(version)) {
        showStatus('sync-status', 'ç‰ˆæœ¬å·æ ¼å¼é”™è¯¯ï¼Œè¯·ä½¿ç”¨ X.Y.Z æ ¼å¼ï¼ˆå¦‚ 1.2.0ï¼‰', 'error');
        return;
      }

      if (!message) {
        showStatus('sync-status', 'è¯·è¾“å…¥æ›´æ–°è¯´æ˜', 'error');
        return;
      }

      // å¦‚æœæ˜¯å…¨é‡è¦†ç›–æ¨¡å¼ï¼Œæ˜¾ç¤ºè­¦å‘Š
      if (syncMode === 'replace') {
        const confirmed = confirm(
          'âš ï¸ è­¦å‘Šï¼šå…¨é‡è¦†ç›–æ¨¡å¼\n\n' +
          'æ­¤æ“ä½œå°†ï¼š\n' +
          '1. åˆ é™¤ svg ç›®å½•ä¸‹çš„æ‰€æœ‰æ—§å›¾æ ‡\n' +
          '2. åªä¿ç•™æœ¬æ¬¡ä¸Šä¼ çš„å›¾æ ‡\n\n' +
          'è¿™æ˜¯ä¸€ä¸ªä¸å¯é€†çš„æ“ä½œï¼\n\n' +
          'ç¡®å®šè¦ç»§ç»­å—ï¼Ÿ'
        );

        if (!confirmed) {
          return;
        }
      }

      isSyncing = true;
      updateSyncButton(true);
      document.getElementById('progress-container').classList.remove('hidden');
      document.getElementById('progress-fill').style.width = '0%';
      document.getElementById('progress-text').textContent = 'å‡†å¤‡å¯¼å‡º SVG...';
      document.getElementById('sync-status').classList.add('hidden');

      postMessage('trigger-sync', { version, message, syncMode });
    }

    // ============================================
    // Auto Version & Changelog
    // ============================================

    /**
     * è·å–å½“å‰ä»“åº“ç‰ˆæœ¬å·å¹¶è‡ªåŠ¨ +1
     */
    async function fetchCurrentVersion(repo, token) {
      if (!repo || !token) {
        console.log('[ç‰ˆæœ¬å·] ç¼ºå°‘ repo æˆ– tokenï¼Œè·³è¿‡è·å–');
        return;
      }

      const versionInput = document.getElementById('version');
      // å¦‚æœå·²ç»æœ‰å€¼ï¼Œä¸è¦†ç›–
      if (versionInput.value) {
        console.log('[ç‰ˆæœ¬å·] å·²æœ‰å€¼ï¼Œè·³è¿‡:', versionInput.value);
        return;
      }

      versionInput.placeholder = 'æ­£åœ¨è·å–...';
      console.log('[ç‰ˆæœ¬å·] å¼€å§‹è·å–:', repo);

      // æ·»åŠ  5 ç§’è¶…æ—¶
      const controller = new AbortController();
      const timeoutId = setTimeout(() => {
        controller.abort();
        console.error('[ç‰ˆæœ¬å·] è¯·æ±‚è¶…æ—¶ (5s)');
      }, 5000);

      try {
        const response = await fetch(`https://api.github.com/repos/${repo}/contents/package.json`, {
          headers: {
            'Authorization': `token ${token}`,
            'Accept': 'application/vnd.github.v3+json'
          },
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        console.log('[ç‰ˆæœ¬å·] API å“åº”çŠ¶æ€:', response.status);

        if (response.ok) {
          const data = await response.json();
          // GitHub API returns content in base64
          const content = atob(data.content);
          const pkg = JSON.parse(content);

          if (pkg.version) {
            const currentVersion = pkg.version;
            const parts = currentVersion.split('.').map(Number);

            if (parts.length === 3 && parts.every(p => !isNaN(p))) {
              // Increment patch version
              parts[2] += 1;
              const nextVersion = parts.join('.');
              versionInput.value = nextVersion;
              versionInput.placeholder = 'å¦‚ 1.2.0';
              console.log(`[ç‰ˆæœ¬å·] è‡ªåŠ¨ç‰ˆæœ¬å·: ${currentVersion} -> ${nextVersion}`);

              showStatus('sync-status', `å·²è‡ªåŠ¨å°†ç‰ˆæœ¬å·æ›´æ–°ä¸º <strong>${nextVersion}</strong>`, 'info');
            } else {
              console.warn('[ç‰ˆæœ¬å·] ç‰ˆæœ¬å·æ ¼å¼å¼‚å¸¸:', currentVersion);
              versionInput.placeholder = 'å¦‚ 1.0.0';
            }
          } else {
            console.warn('[ç‰ˆæœ¬å·] package.json ä¸­æ²¡æœ‰ version å­—æ®µ');
            versionInput.placeholder = 'å¦‚ 1.0.0';
          }
        } else {
          const errorText = await response.text();
          console.error('[ç‰ˆæœ¬å·] API è¯·æ±‚å¤±è´¥:', response.status, errorText);
          versionInput.placeholder = 'å¦‚ 1.0.0';

          if (response.status === 404) {
            showStatus('sync-status', 'æç¤ºï¼šä»“åº“ä¸­æœªæ‰¾åˆ° package.jsonï¼Œè¯·æ‰‹åŠ¨è¾“å…¥ç‰ˆæœ¬å·', 'info');
          }
        }
      } catch (error) {
        clearTimeout(timeoutId);
        if (error.name === 'AbortError') {
          console.error('[ç‰ˆæœ¬å·] è¯·æ±‚è¶…æ—¶');
          showStatus('sync-status', 'ç‰ˆæœ¬å·è·å–è¶…æ—¶ï¼Œè¯·æ‰‹åŠ¨è¾“å…¥', 'info');
        } else {
          console.error('[ç‰ˆæœ¬å·] è·å–ç‰ˆæœ¬å·å¤±è´¥:', error);
        }
        versionInput.placeholder = 'å¦‚ 1.0.0';
      }
    }

    /**
     * æ ¹æ®å›¾æ ‡åˆ—è¡¨ç”Ÿæˆé»˜è®¤æ›´æ–°è¯´æ˜
     */
    function generateDefaultChangelog(icons, isSelection) {
      if (!icons || icons.length === 0) return;

      const messageInput = document.getElementById('message');

      // ç”Ÿæˆå›¾æ ‡åç§°åˆ—è¡¨ï¼ˆæœ€å¤šæ˜¾ç¤º 5 ä¸ªï¼‰
      const names = icons.slice(0, 5).map(i => i.name).join(', ');
      const suffix = icons.length > 5 ? ` ç­‰ ${icons.length} ä¸ªå›¾æ ‡` : ' å›¾æ ‡';
      const action = isSelection ? 'æ›´æ–°/æ–°å¢' : 'åŒæ­¥';

      const defaultMessage = `${action} ${icons.length} ä¸ªå›¾æ ‡ï¼š${names}${icons.length > 5 ? '' : suffix}`;

      // åªæœ‰å½“è¾“å…¥æ¡†ä¸ºç©ºï¼Œæˆ–è€…å†…å®¹çœ‹èµ·æ¥åƒæ˜¯ä¹‹å‰è‡ªåŠ¨ç”Ÿæˆçš„æ—¶æ‰è¦†ç›–
      if (!messageInput.value || messageInput.value.includes('æ›´æ–°/æ–°å¢') || messageInput.value.includes('åŒæ­¥')) {
        messageInput.value = defaultMessage;
      }
    }

    async function handleSyncResult(data) {
      if (data.action === 'trigger-github') {
        // Update progress
        document.getElementById('progress-text').textContent = 'æ­£åœ¨ä¸Šä¼ åˆ° GitHub...';
        document.getElementById('progress-fill').style.width = '100%';

        // Upload SVG files directly to GitHub
        try {
          const result = await uploadToGitHub(
            data.config.githubRepo,
            data.config.githubToken,
            data.syncRequest
          );

          document.getElementById('progress-container').classList.add('hidden');

          if (result.success) {
            showSuccessOverlay('åŒæ­¥æˆåŠŸ!', `ç‰ˆæœ¬ ${data.syncRequest.version} / ${data.syncRequest.icons.length} ä¸ªå›¾æ ‡å·²ä¸Šä¼ `);

            // Clear form after successful sync
            document.getElementById('version').value = '';
            document.getElementById('message').value = '';

            // ç›´æ¥ä½¿ç”¨åˆšåˆšä¸Šä¼ çš„ç‰ˆæœ¬å· +1ï¼Œä¸éœ€è¦ç­‰å¾…è¿œç¨‹æ›´æ–°
            const uploadedVersion = data.syncRequest.version;
            if (uploadedVersion) {
              const parts = uploadedVersion.split('.').map(Number);
              if (parts.length === 3 && parts.every(p => !isNaN(p))) {
                parts[2] += 1;
                const nextVersion = parts.join('.');
                document.getElementById('version').value = nextVersion;
                console.log(`[ç‰ˆæœ¬å·] åŸºäºä¸Šä¼ ç‰ˆæœ¬è®¡ç®—ä¸‹ä¸€ç‰ˆæœ¬: ${uploadedVersion} -> ${nextVersion}`);
              }
            }
          } else {
            showSyncError(result.error);
          }
        } catch (error) {
          document.getElementById('progress-container').classList.add('hidden');
          showSyncError(error.message);
        }

        isSyncing = false;
        updateSyncButton(false);
      }
    }

    function showSyncError(errorMessage) {
      let suggestion = '';

      if (errorMessage.includes('404')) {
        suggestion = 'è¯·æ£€æŸ¥ä»“åº“æ˜¯å¦å­˜åœ¨ä»¥åŠ Token æ˜¯å¦æœ‰è®¿é—®æƒé™ã€‚';
      } else if (errorMessage.includes('401') || errorMessage.includes('403')) {
        suggestion = 'GitHub Token å¯èƒ½æ— æ•ˆæˆ–å·²è¿‡æœŸï¼Œè¯·åœ¨è®¾ç½®ä¸­æ›´æ–°ã€‚';
      } else if (errorMessage.includes('network') || errorMessage.includes('fetch')) {
        suggestion = 'è¯·æ£€æŸ¥ç½‘ç»œè¿æ¥åé‡è¯•ã€‚';
      }

      showStatus('sync-status', `
        <strong>âœ— åŒæ­¥å¤±è´¥</strong><br>
        <div style="margin-top: 4px;">
          ${escapeHtml(errorMessage)}
          ${suggestion ? `<br><br><em>${suggestion}</em>` : ''}
        </div>
        <button class="btn btn-secondary" style="margin-top: 8px;" onclick="triggerSync()">
          é‡è¯•
        </button>
      `, 'error');
    }

    /**
     * ç›´æ¥ä¸Šä¼  SVG æ–‡ä»¶åˆ° GitHub å¹¶åˆ›å»º PR
     */
    async function uploadToGitHub(repo, token, syncRequest) {
      const headers = {
        'Accept': 'application/vnd.github.v3+json',
        'Authorization': `token ${token}`,
        'Content-Type': 'application/json'
      };

      try {
        // 1. è·å–é»˜è®¤åˆ†æ”¯çš„æœ€æ–° commit SHA
        const repoResponse = await fetch(`https://api.github.com/repos/${repo}`, { headers });
        if (!repoResponse.ok) {
          throw new Error(`è·å–ä»“åº“ä¿¡æ¯å¤±è´¥: ${repoResponse.status}`);
        }
        const repoData = await repoResponse.json();
        const defaultBranch = repoData.default_branch;

        // è·å–é»˜è®¤åˆ†æ”¯çš„ ref
        const refResponse = await fetch(`https://api.github.com/repos/${repo}/git/ref/heads/${defaultBranch}`, { headers });
        if (!refResponse.ok) {
          throw new Error(`è·å–åˆ†æ”¯ä¿¡æ¯å¤±è´¥: ${refResponse.status}`);
        }
        const refData = await refResponse.json();
        const baseSha = refData.object.sha;

        // 2. åˆ›å»ºæ–°åˆ†æ”¯
        const branchName = `icon-sync-${syncRequest.version}-${Date.now()}`;
        const createBranchResponse = await fetch(`https://api.github.com/repos/${repo}/git/refs`, {
          method: 'POST',
          headers,
          body: JSON.stringify({
            ref: `refs/heads/${branchName}`,
            sha: baseSha
          })
        });

        if (!createBranchResponse.ok) {
          const error = await createBranchResponse.json();
          throw new Error(`åˆ›å»ºåˆ†æ”¯å¤±è´¥: ${error.message || createBranchResponse.status}`);
        }

        // 3. å¦‚æœæ˜¯å…¨é‡è¦†ç›–æ¨¡å¼ï¼Œåˆ é™¤ svg ç›®å½•ä¸‹çš„æ‰€æœ‰æ—§æ–‡ä»¶
        if (syncRequest.syncMode === 'replace') {
          document.getElementById('progress-text').textContent = 'æ­£åœ¨åˆ é™¤æ—§å›¾æ ‡...';

          try {
            // è·å– svg ç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶ï¼ˆä» main åˆ†æ”¯è·å–ï¼Œç¡®ä¿è·å–åˆ°æ‰€æœ‰æ—§æ–‡ä»¶ï¼‰
            const svgDirResponse = await fetch(
              `https://api.github.com/repos/${repo}/contents/svg?ref=${defaultBranch}`,
              { headers }
            );

            if (svgDirResponse.status === 200) {
              const files = await svgDirResponse.json();
              const svgFiles = files.filter(f => f.name.endsWith('.svg'));

              // åˆ›å»ºæœ¬æ¬¡ä¸Šä¼ çš„æ–‡ä»¶åé›†åˆï¼ˆç”¨äºå¯¹æ¯”ï¼‰
              const uploadingFileNames = new Set(
                syncRequest.icons.map(icon => sanitizeFilename(icon.name) + '.svg')
              );

              // æ‰¾å‡ºéœ€è¦åˆ é™¤çš„æ–‡ä»¶ï¼ˆä¸åœ¨æœ¬æ¬¡ä¸Šä¼ åˆ—è¡¨ä¸­çš„æ–‡ä»¶ï¼‰
              const filesToDelete = svgFiles.filter(f => !uploadingFileNames.has(f.name));

              console.log(`æ‰¾åˆ° ${svgFiles.length} ä¸ªç°æœ‰æ–‡ä»¶ï¼Œæœ¬æ¬¡ä¸Šä¼  ${uploadingFileNames.size} ä¸ªæ–‡ä»¶`);
              console.log(`éœ€è¦åˆ é™¤ ${filesToDelete.length} ä¸ªæ—§æ–‡ä»¶`);

              if (filesToDelete.length > 0) {
                // æ‰¹é‡åˆ é™¤æ—§æ–‡ä»¶
                const deleteBatchSize = 5;
                let deletedCount = 0;

                for (let i = 0; i < filesToDelete.length; i += deleteBatchSize) {
                  const deleteBatch = filesToDelete.slice(i, i + deleteBatchSize);

                  await Promise.all(deleteBatch.map(async (file) => {
                    try {
                      const deleteResponse = await fetch(
                        `https://api.github.com/repos/${repo}/contents/${file.path}`,
                        {
                          method: 'DELETE',
                          headers,
                          body: JSON.stringify({
                            message: `Delete old icon: ${file.name}`,
                            sha: file.sha,
                            branch: branchName
                          })
                        }
                      );

                      if (deleteResponse.ok) {
                        deletedCount++;
                        console.log(`âœ… å·²åˆ é™¤: ${file.name}`);
                      } else {
                        console.warn(`âš ï¸ åˆ é™¤å¤±è´¥: ${file.name}`);
                      }
                    } catch (error) {
                      console.error(`åˆ é™¤ ${file.name} æ—¶å‡ºé”™:`, error);
                    }
                  }));

                  // æ‰¹æ¬¡é—´å»¶è¿Ÿ
                  if (i + deleteBatchSize < filesToDelete.length) {
                    await new Promise(resolve => setTimeout(resolve, 1000));
                  }
                }

                console.log(`âœ… å·²åˆ é™¤ ${deletedCount}/${filesToDelete.length} ä¸ªæ—§å›¾æ ‡`);
              } else {
                console.log('âœ… æ²¡æœ‰éœ€è¦åˆ é™¤çš„æ—§æ–‡ä»¶');
              }
            }

            // æ³¨æ„ï¼šæˆ‘ä»¬ä¸è¦åˆ é™¤ icons.jsonï¼Œä»¥ä¾¿æ„å»ºè„šæœ¬å¯ä»¥è¯»å–æ—§çš„ createdAt æ—¶é—´æˆ³
            // æ„å»ºè„šæœ¬ä¼šè‡ªåŠ¨æ ¹æ®å­˜åœ¨çš„ SVG æ–‡ä»¶æ›´æ–° icons.jsonï¼Œç§»é™¤ä¸å­˜åœ¨çš„å›¾æ ‡
            console.log('ä¿ç•™è¿œç¨‹ icons.json ä»¥ç»§æ‰¿æ—¶é—´æˆ³ä¿¡æ¯');

            // æ—§ä»£ç é€»è¾‘ï¼šæ›¾åœ¨è¿™é‡Œåˆ é™¤ icons.json å’Œ icons-manifest.json
            // ç°åœ¨å·²ç§»é™¤è¯¥é€»è¾‘ï¼Œä»¥æ”¯æŒå¢é‡æ—¶é—´æˆ³æ›´æ–°

          } catch (error) {
            console.warn('åˆ é™¤æ—§æ–‡ä»¶æ—¶å‡ºé”™:', error);
            // ç»§ç»­æ‰§è¡Œï¼Œä¸ä¸­æ–­æµç¨‹
          }
        }

        // 3.5 å¢é‡æ¨¡å¼ä¸‹æ£€æµ‹é‡åå¹¶é‡å‘½åå›¾æ ‡
        if (syncRequest.syncMode !== 'replace') {
          document.getElementById('progress-text').textContent = 'æ­£åœ¨æ£€æµ‹é‡åå›¾æ ‡...';

          try {
            // è·å–ç°æœ‰çš„ icons.json
            const existingJsonResponse = await fetch(
              `https://api.github.com/repos/${repo}/contents/icons.json?ref=${defaultBranch}`,
              { headers }
            );

            if (existingJsonResponse.status === 200) {
              const fileData = await existingJsonResponse.json();
              // ä½¿ç”¨æ­£ç¡®çš„ UTF-8 è§£ç æ–¹æ³•ï¼ˆatob ä¸èƒ½æ­£ç¡®å¤„ç†ä¸­æ–‡ï¼‰
              const binaryString = atob(fileData.content);
              const bytes = new Uint8Array(binaryString.length);
              for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
              }
              const content = new TextDecoder('utf-8').decode(bytes);
              const existingJson = JSON.parse(content);
              const existingIcons = existingJson.icons || [];
              const existingOriginalNames = new Set(existingIcons.map(i => i.originalName));

              // æ£€æµ‹å¹¶é‡å‘½åé‡åå›¾æ ‡
              const usedNames = new Set(existingOriginalNames);

              console.log(`ğŸ“‹ ç°æœ‰å›¾æ ‡åç§°: ${[...existingOriginalNames].join(', ')}`);
              console.log(`ğŸ“‹ æ–°ä¸Šä¼ å›¾æ ‡åç§°: ${syncRequest.icons.map(i => i.name).join(', ')}`);

              syncRequest.icons = syncRequest.icons.map(icon => {
                let finalName = icon.name;
                let suffix = 1;

                // æ£€æŸ¥æ˜¯å¦é‡å
                while (usedNames.has(finalName)) {
                  finalName = `${icon.name}${suffix}`;
                  suffix++;
                }

                // å¦‚æœé‡å‘½åäº†ï¼Œè¾“å‡ºæ—¥å¿—
                if (suffix > 1) {
                  console.log(`ğŸ”„ æ£€æµ‹åˆ°é‡åå›¾æ ‡ï¼š${icon.name} â†’ ${finalName}`);
                }

                // å°†æ–°åç§°åŠ å…¥å·²ç”¨åç§°é›†åˆï¼ˆé¿å…æœ¬æ¬¡ä¸Šä¼ å†…éƒ¨é‡åï¼‰
                usedNames.add(finalName);

                return {
                  ...icon,
                  name: finalName
                };
              });

              console.log(`ğŸ“‹ é‡åæ£€æµ‹å®Œæˆï¼Œå…± ${syncRequest.icons.length} ä¸ªå›¾æ ‡`);
            }
          } catch (e) {
            console.log('ğŸ“‹ é¦–æ¬¡ä¸Šä¼ ï¼Œæ— éœ€æ£€æµ‹é‡å');
          }
        }

        // 4. ä¸Šä¼ æ¯ä¸ª SVG æ–‡ä»¶ï¼ˆæ‰¹é‡å¤„ç†ï¼Œé¿å…é€Ÿç‡é™åˆ¶ï¼‰
        document.getElementById('progress-text').textContent = 'æ­£åœ¨ä¸Šä¼ æ–°å›¾æ ‡...';
        let uploadedCount = 0;
        const failedFiles = [];
        const batchSize = 2; // æ¯æ‰¹ä¸Šä¼  2 ä¸ªæ–‡ä»¶ï¼ˆé™ä½å¹¶å‘åº¦é¿å…å†²çªï¼‰

        for (let i = 0; i < syncRequest.icons.length; i += batchSize) {
          const batch = syncRequest.icons.slice(i, i + batchSize);

          // å¹¶è¡Œä¸Šä¼ å½“å‰æ‰¹æ¬¡
          const uploadPromises = batch.map(async (icon) => {
            const fileName = sanitizeFilename(icon.name) + '.svg';
            const filePath = `svg/${fileName}`;

            // ä½¿ç”¨æ›´å¯é çš„ base64 ç¼–ç æ–¹æ³•
            const utf8Bytes = new TextEncoder().encode(icon.svg);
            const binaryString = Array.from(utf8Bytes, byte => String.fromCharCode(byte)).join('');
            const content = btoa(binaryString);

            try {
              // ç­–ç•¥ 1: å…ˆå°è¯•ä»æ–°åˆ†æ”¯è·å–æ–‡ä»¶ SHA
              let fileSha = null;
              try {
                const branchFileCheck = await fetch(
                  `https://api.github.com/repos/${repo}/contents/${filePath}?ref=${branchName}`,
                  { headers }
                );
                if (branchFileCheck.status === 200) {
                  const fileData = await branchFileCheck.json();
                  fileSha = fileData.sha;
                  console.log(`æ–‡ä»¶ ${fileName} åœ¨åˆ†æ”¯ ${branchName} ä¸Šå·²å­˜åœ¨ï¼ŒSHA: ${fileSha}`);
                }
              } catch (e) {
                // æ–‡ä»¶åœ¨æ–°åˆ†æ”¯ä¸Šä¸å­˜åœ¨
              }

              // ç­–ç•¥ 2: å¦‚æœæ–°åˆ†æ”¯ä¸Šæ²¡æœ‰ï¼Œå°è¯•ä» main åˆ†æ”¯è·å–
              if (!fileSha) {
                try {
                  const mainFileCheck = await fetch(
                    `https://api.github.com/repos/${repo}/contents/${filePath}?ref=main`,
                    { headers }
                  );
                  if (mainFileCheck.status === 200) {
                    const fileData = await mainFileCheck.json();
                    fileSha = fileData.sha;
                    console.log(`æ–‡ä»¶ ${fileName} åœ¨ main åˆ†æ”¯ä¸Šå­˜åœ¨ï¼ŒSHA: ${fileSha}`);
                  }
                } catch (e) {
                  // æ–‡ä»¶åœ¨ main åˆ†æ”¯ä¸Šä¹Ÿä¸å­˜åœ¨ï¼Œè¿™æ˜¯æ–°æ–‡ä»¶
                  console.log(`æ–‡ä»¶ ${fileName} æ˜¯æ–°æ–‡ä»¶`);
                }
              }

              const updateBody = {
                message: `Add/Update ${fileName}`,
                content: content,
                branch: branchName
              };

              // å¦‚æœæ‰¾åˆ°äº† SHAï¼Œæ·»åŠ åˆ°è¯·æ±‚ä¸­
              if (fileSha) {
                updateBody.sha = fileSha;
              }

              // ä¸Šä¼ æ–‡ä»¶
              let updateResponse = await fetch(`https://api.github.com/repos/${repo}/contents/${filePath}`, {
                method: 'PUT',
                headers,
                body: JSON.stringify(updateBody)
              });

              // ç­–ç•¥ 3: å¦‚æœæ˜¯ 409ï¼ˆå†²çªï¼‰æˆ– 422ï¼ˆç¼ºå°‘SHAï¼‰ï¼Œå°è¯•è·å–æœ€æ–° SHA å¹¶é‡è¯•
              if (updateResponse.status === 409 || updateResponse.status === 422) {
                const errorType = updateResponse.status === 409 ? 'å†²çª' : 'ç¼ºå°‘SHA';
                console.warn(`æ–‡ä»¶ ${fileName} ${errorType}ï¼ˆ${updateResponse.status}ï¼‰ï¼Œå°è¯•è·å–æœ€æ–° SHA...`);

                // æœ€å¤šé‡è¯• 5 æ¬¡
                for (let retryCount = 0; retryCount < 5; retryCount++) {
                  // ç­‰å¾…æ—¶é—´é€æ¸å¢åŠ ï¼ˆ2ç§’ã€3ç§’ã€4ç§’...ï¼‰
                  const waitTime = (retryCount + 2) * 1000;
                  console.log(`ç­‰å¾… ${waitTime / 1000} ç§’åé‡è¯•...`);
                  await new Promise(resolve => setTimeout(resolve, waitTime));

                  // å°è¯•ä»æ–°åˆ†æ”¯è·å– SHA
                  let foundSha = false;
                  try {
                    const retryCheck = await fetch(
                      `https://api.github.com/repos/${repo}/contents/${filePath}?ref=${branchName}`,
                      { headers }
                    );
                    if (retryCheck.status === 200) {
                      const fileData = await retryCheck.json();
                      updateBody.sha = fileData.sha;
                      foundSha = true;
                      console.log(`é‡è¯• ${retryCount + 1}: ä»æ–°åˆ†æ”¯è·å–åˆ° SHA: ${fileData.sha.substring(0, 8)}...`);
                    }
                  } catch (e) {
                    console.log(`é‡è¯• ${retryCount + 1}: æ— æ³•ä»æ–°åˆ†æ”¯è·å– SHA`);
                  }

                  // å¦‚æœæ–°åˆ†æ”¯æ²¡æ‰¾åˆ°ï¼Œå°è¯•ä» main åˆ†æ”¯è·å–
                  if (!foundSha) {
                    try {
                      const mainCheck = await fetch(
                        `https://api.github.com/repos/${repo}/contents/${filePath}?ref=${defaultBranch}`,
                        { headers }
                      );
                      if (mainCheck.status === 200) {
                        const fileData = await mainCheck.json();
                        updateBody.sha = fileData.sha;
                        foundSha = true;
                        console.log(`é‡è¯• ${retryCount + 1}: ä» ${defaultBranch} åˆ†æ”¯è·å–åˆ° SHA: ${fileData.sha.substring(0, 8)}...`);
                      }
                    } catch (e) {
                      console.log(`é‡è¯• ${retryCount + 1}: æ— æ³•ä» ${defaultBranch} åˆ†æ”¯è·å– SHA`);
                    }
                  }

                  // å¦‚æœä»ç„¶æ²¡æ‰¾åˆ° SHAï¼Œè¯´æ˜æ˜¯æ–°æ–‡ä»¶
                  if (!foundSha) {
                    delete updateBody.sha;
                    console.log(`é‡è¯• ${retryCount + 1}: æ–‡ä»¶åœ¨ä¸¤ä¸ªåˆ†æ”¯éƒ½ä¸å­˜åœ¨ï¼Œä½œä¸ºæ–°æ–‡ä»¶ä¸Šä¼ `);
                  }

                  // é‡è¯•ä¸Šä¼ 
                  updateResponse = await fetch(`https://api.github.com/repos/${repo}/contents/${filePath}`, {
                    method: 'PUT',
                    headers,
                    body: JSON.stringify(updateBody)
                  });

                  // å¦‚æœæˆåŠŸæˆ–ä¸å†æ˜¯ 409/422ï¼Œè·³å‡ºå¾ªç¯
                  if (updateResponse.ok || (updateResponse.status !== 409 && updateResponse.status !== 422)) {
                    if (updateResponse.ok) {
                      console.log(`é‡è¯• ${retryCount + 1}: ä¸Šä¼ æˆåŠŸï¼`);
                    }
                    break;
                  }
                }
              }

              if (updateResponse.ok || updateResponse.status === 201) {
                console.log(`âœ… ${fileName} ä¸Šä¼ æˆåŠŸ`);
                return { success: true, fileName };
              } else {
                const error = await updateResponse.json().catch(() => ({}));
                console.error(`âŒ ${fileName} ä¸Šä¼ å¤±è´¥:`, {
                  status: updateResponse.status,
                  statusText: updateResponse.statusText,
                  error: error,
                  filePath: filePath,
                  branch: branchName,
                  hasSha: !!fileSha
                });
                return {
                  success: false,
                  fileName,
                  status: updateResponse.status,
                  error: error.message || `HTTP ${updateResponse.status}: ${updateResponse.statusText}`
                };
              }
            } catch (error) {
              console.error(`âŒ ${fileName} ä¸Šä¼ å¼‚å¸¸:`, error);
              return { success: false, fileName, error: error.message };
            }
          });

          // ç­‰å¾…å½“å‰æ‰¹æ¬¡å®Œæˆ
          const results = await Promise.all(uploadPromises);
          const successCount = results.filter(r => r.success).length;
          uploadedCount += successCount;

          // è®°å½•å¤±è´¥çš„æ–‡ä»¶
          results.filter(r => !r.success).forEach(r => {
            failedFiles.push(r);
          });

          // æ›´æ–°è¿›åº¦
          const progress = Math.round(((i + batch.length) / syncRequest.icons.length) * 100);
          document.getElementById('progress-fill').style.width = `${progress}%`;
          document.getElementById('progress-text').textContent =
            `ä¸Šä¼ ä¸­: ${Math.min(i + batch.length, syncRequest.icons.length)}/${syncRequest.icons.length} (æˆåŠŸ: ${uploadedCount}, å¤±è´¥: ${failedFiles.length})`;

          // æ‰¹æ¬¡ä¹‹é—´ç¨å¾®å»¶è¿Ÿï¼Œé¿å…é€Ÿç‡é™åˆ¶
          if (i + batchSize < syncRequest.icons.length) {
            await new Promise(resolve => setTimeout(resolve, 2000)); // å¢åŠ åˆ° 2 ç§’
          }
        }

        // æ˜¾ç¤ºä¸Šä¼ ç»“æœæ‘˜è¦
        console.log(`\nä¸Šä¼ å®Œæˆ: æˆåŠŸ ${uploadedCount}/${syncRequest.icons.length}`);
        if (failedFiles.length > 0) {
          console.warn(`å¤±è´¥çš„æ–‡ä»¶ (${failedFiles.length}):`, failedFiles.map(f => f.fileName));
        }

        // æ˜¾ç¤ºä¸Šä¼ ç»“æœæ‘˜è¦
        console.log(`\nä¸Šä¼ å®Œæˆ: æˆåŠŸ ${uploadedCount}/${syncRequest.icons.length}`);
        if (failedFiles.length > 0) {
          console.warn(`å¤±è´¥çš„æ–‡ä»¶ (${failedFiles.length}):`, failedFiles.map(f => f.fileName));
        }

        if (uploadedCount === 0) {
          throw new Error('æ²¡æœ‰æˆåŠŸä¸Šä¼ ä»»ä½•æ–‡ä»¶ã€‚è¯·æ£€æŸ¥æ§åˆ¶å°æŸ¥çœ‹è¯¦ç»†é”™è¯¯ä¿¡æ¯ã€‚');
        }

        if (uploadedCount < syncRequest.icons.length) {
          const failedCount = syncRequest.icons.length - uploadedCount;
          console.warn(`âš ï¸ éƒ¨åˆ†æ–‡ä»¶ä¸Šä¼ å¤±è´¥: ${uploadedCount}/${syncRequest.icons.length} æˆåŠŸ`);

          // æ˜¾ç¤ºå¤±è´¥æ–‡ä»¶åˆ—è¡¨
          if (failedFiles.length > 0) {
            console.group('å¤±è´¥çš„æ–‡ä»¶è¯¦æƒ…:');
            failedFiles.forEach(f => {
              console.error(`- ${f.fileName}: ${f.error} (çŠ¶æ€: ${f.status || 'N/A'})`);
            });
            console.groupEnd();
          }

          // è¯¢é—®ç”¨æˆ·æ˜¯å¦ç»§ç»­
          const continueAnyway = confirm(
            `âš ï¸ è­¦å‘Šï¼š${failedCount} ä¸ªæ–‡ä»¶ä¸Šä¼ å¤±è´¥\n\n` +
            `æˆåŠŸ: ${uploadedCount}\n` +
            `å¤±è´¥: ${failedCount}\n\n` +
            `æ˜¯å¦ç»§ç»­åˆ›å»º PRï¼Ÿ\n\n` +
            `ï¼ˆå¤±è´¥çš„æ–‡ä»¶ä¸ä¼šåŒ…å«åœ¨ PR ä¸­ï¼Œä½ å¯ä»¥ç¨åé‡æ–°ä¸Šä¼ ï¼‰`
          );

          if (!continueAnyway) {
            throw new Error('ç”¨æˆ·å–æ¶ˆæ“ä½œ');
          }
        }

        // 5. ç”Ÿæˆå¹¶ä¸Šä¼  icons.json æ–‡ä»¶
        document.getElementById('progress-text').textContent = 'æ­£åœ¨ç”Ÿæˆ icons.json...';

        try {
          // è·å–åŒæ­¥æ¨¡å¼
          const isIncrementalMode = (syncRequest.syncMode || 'incremental') === 'incremental';
          let existingIcons = [];

          // å¢é‡æ¨¡å¼ä¸‹ï¼Œå…ˆè·å–ç°æœ‰çš„ icons.json
          if (isIncrementalMode) {
            try {
              const existingJsonResponse = await fetch(
                `https://api.github.com/repos/${repo}/contents/icons.json?ref=${branchName}`,
                { headers }
              );
              if (existingJsonResponse.status === 200) {
                const fileData = await existingJsonResponse.json();
                // ä½¿ç”¨æ­£ç¡®çš„ UTF-8 è§£ç æ–¹æ³•ï¼ˆatob ä¸èƒ½æ­£ç¡®å¤„ç†ä¸­æ–‡ï¼‰
                const binaryString = atob(fileData.content);
                const bytes = new Uint8Array(binaryString.length);
                for (let i = 0; i < binaryString.length; i++) {
                  bytes[i] = binaryString.charCodeAt(i);
                }
                const content = new TextDecoder('utf-8').decode(bytes);
                const existingJson = JSON.parse(content);
                existingIcons = existingJson.icons || [];
                console.log(`ğŸ“‹ å¢é‡æ¨¡å¼ï¼šå·²åŠ è½½ ${existingIcons.length} ä¸ªç°æœ‰å›¾æ ‡`);
              }
            } catch (e) {
              console.log('ğŸ“‹ é¦–æ¬¡ä¸Šä¼ ï¼Œæ— ç°æœ‰å›¾æ ‡');
            }
          }

          // ç”Ÿæˆæ–°å›¾æ ‡åˆ—è¡¨ï¼ˆå…ˆæš‚æ—¶ä¸å¤„ç†é‡åï¼Œç¨ååœ¨åˆå¹¶æ—¶å¤„ç†ï¼‰
          const rawNewIcons = syncRequest.icons.map(icon => ({
            name: generateComponentName(icon.name),
            originalName: icon.name,
            svgPath: `svg/${sanitizeFilename(icon.name)}.svg`,
            componentPath: `src/icons/${generateComponentName(icon.name)}.tsx`,
            size: {
              width: icon.width || 24,
              height: icon.height || 24
            },
            uploadedAt: new Date().toISOString()  // æ·»åŠ ä¸Šä¼ æ—¶é—´ç”¨äºæ’åº
          }));

          // åˆå¹¶å›¾æ ‡åˆ—è¡¨ï¼ˆå¤„ç†é‡åï¼‰
          let mergedIcons;
          if (isIncrementalMode && existingIcons.length > 0) {
            // å¢é‡æ¨¡å¼ï¼šéœ€è¦å¤„ç†é‡å
            const existingNames = new Set(existingIcons.map(i => i.name));
            const existingOriginalNames = new Set(existingIcons.map(i => i.originalName));

            // å¤„ç†é‡åå›¾æ ‡
            const newIcons = rawNewIcons.map(icon => {
              let finalName = icon.name;
              let finalOriginalName = icon.originalName;
              let finalSvgPath = icon.svgPath;
              let finalComponentPath = icon.componentPath;
              let suffix = 1;

              // æ£€æŸ¥æ˜¯å¦é‡åï¼ˆåŸºäº originalNameï¼‰
              while (existingOriginalNames.has(finalOriginalName)) {
                finalOriginalName = `${icon.originalName}${suffix}`;
                finalName = generateComponentName(finalOriginalName);
                finalSvgPath = `svg/${sanitizeFilename(finalOriginalName)}.svg`;
                finalComponentPath = `src/icons/${finalName}.tsx`;
                suffix++;
              }

              // å¦‚æœé‡å‘½åäº†ï¼Œè¾“å‡ºæ—¥å¿—
              if (suffix > 1) {
                console.log(`ğŸ”„ å›¾æ ‡é‡åï¼š${icon.originalName} â†’ ${finalOriginalName}`);
              }

              return {
                ...icon,
                name: finalName,
                originalName: finalOriginalName,
                svgPath: finalSvgPath,
                componentPath: finalComponentPath
              };
            });

            // æ–°å›¾æ ‡æ’åœ¨å‰é¢ï¼Œç°æœ‰å›¾æ ‡æ’åœ¨åé¢
            mergedIcons = [...newIcons, ...existingIcons];
            console.log(`ğŸ“‹ åˆå¹¶ç»“æœï¼š${newIcons.length} ä¸ªæ–°å›¾æ ‡ï¼ˆæ’åœ¨å‰é¢ï¼‰+ ${existingIcons.length} ä¸ªç°æœ‰å›¾æ ‡ = ${mergedIcons.length} ä¸ªæ€»è®¡`);
          } else {
            // å…¨é‡æ¨¡å¼ï¼šåªä¿ç•™æ–°å›¾æ ‡
            mergedIcons = rawNewIcons;
            console.log(`ğŸ“‹ å…¨é‡æ¨¡å¼ï¼š${rawNewIcons.length} ä¸ªå›¾æ ‡`);
          }

          // ç”Ÿæˆ icons.json å†…å®¹
          const iconsJsonContent = {
            version: syncRequest.version,
            syncMode: syncRequest.syncMode || 'incremental',  // è®°å½•åŒæ­¥æ¨¡å¼
            generatedAt: new Date().toISOString(),
            totalCount: mergedIcons.length,
            icons: mergedIcons
          };

          // å°† JSON è½¬æ¢ä¸º base64
          const jsonString = JSON.stringify(iconsJsonContent, null, 2);
          const jsonBase64 = btoa(unescape(encodeURIComponent(jsonString)));

          // æ£€æŸ¥ icons.json æ˜¯å¦å·²å­˜åœ¨ï¼ˆè·å– SHAï¼‰
          let iconsJsonSha = null;
          let rootIconsJsonSha = null;

          try {
            const checkResponse = await fetch(
              `https://api.github.com/repos/${repo}/contents/docs/public/icons.json?ref=${branchName}`,
              { headers }
            );
            if (checkResponse.status === 200) {
              const fileData = await checkResponse.json();
              iconsJsonSha = fileData.sha;
            }
          } catch (e) {
            // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿™æ˜¯æ­£å¸¸çš„
          }

          // æ£€æŸ¥æ ¹ç›®å½•çš„ icons.json
          try {
            const rootCheckResponse = await fetch(
              `https://api.github.com/repos/${repo}/contents/icons.json?ref=${branchName}`,
              { headers }
            );
            if (rootCheckResponse.status === 200) {
              const fileData = await rootCheckResponse.json();
              rootIconsJsonSha = fileData.sha;
            }
          } catch (e) {
            // æ–‡ä»¶ä¸å­˜åœ¨ï¼Œè¿™æ˜¯æ­£å¸¸çš„
          }

          // ä¸Šä¼  icons.json åˆ° docs/public/
          const uploadJsonBody = {
            message: `Update icons.json for v${syncRequest.version}`,
            content: jsonBase64,
            branch: branchName
          };

          if (iconsJsonSha) {
            uploadJsonBody.sha = iconsJsonSha;
          }

          const uploadJsonResponse = await fetch(
            `https://api.github.com/repos/${repo}/contents/docs/public/icons.json`,
            {
              method: 'PUT',
              headers,
              body: JSON.stringify(uploadJsonBody)
            }
          );

          if (uploadJsonResponse.ok) {
            console.log('âœ… docs/public/icons.json ä¸Šä¼ æˆåŠŸ');
          } else {
            console.warn('âš ï¸ docs/public/icons.json ä¸Šä¼ å¤±è´¥');
          }

          // ä¸Šä¼  icons.json åˆ°æ ¹ç›®å½•ï¼ˆGitHub Actions éœ€è¦ï¼‰
          const rootUploadJsonBody = {
            message: `Update icons.json for v${syncRequest.version}`,
            content: jsonBase64,
            branch: branchName
          };

          if (rootIconsJsonSha) {
            rootUploadJsonBody.sha = rootIconsJsonSha;
          }

          const rootUploadJsonResponse = await fetch(
            `https://api.github.com/repos/${repo}/contents/icons.json`,
            {
              method: 'PUT',
              headers,
              body: JSON.stringify(rootUploadJsonBody)
            }
          );

          if (rootUploadJsonResponse.ok) {
            console.log('âœ… icons.json ä¸Šä¼ æˆåŠŸ');
          } else {
            console.warn('âš ï¸ icons.json ä¸Šä¼ å¤±è´¥ï¼Œä½†ç»§ç»­åˆ›å»º PR');
          }
        } catch (error) {
          console.error('ç”Ÿæˆæˆ–ä¸Šä¼  icons.json æ—¶å‡ºé”™:', error);
          // ç»§ç»­æ‰§è¡Œï¼Œä¸ä¸­æ–­æµç¨‹
        }

        // 6. åˆ›å»º Pull Request
        const prTitle = syncRequest.syncMode === 'replace'
          ? `ğŸ”„ å…¨é‡æ›´æ–°å›¾æ ‡: v${syncRequest.version}`
          : `ğŸ¨ å›¾æ ‡æ›´æ–°: v${syncRequest.version}`;

        const prBody = syncRequest.syncMode === 'replace'
          ? `## å…¨é‡æ›´æ–°å›¾æ ‡

**ç‰ˆæœ¬:** ${syncRequest.version}
**è¯´æ˜:** ${syncRequest.message}
**æ¨¡å¼:** å…¨é‡è¦†ç›–

æ­¤ PR ç”± Figma æ’ä»¶è‡ªåŠ¨ç”Ÿæˆã€‚

### å˜æ›´å†…å®¹
- âš ï¸ åˆ é™¤äº†æ‰€æœ‰æ—§å›¾æ ‡
- âœ… ä¸Šä¼ äº† ${uploadedCount} ä¸ªæ–°å›¾æ ‡

### æ³¨æ„
è¿™æ˜¯ä¸€ä¸ªå…¨é‡è¦†ç›–æ›´æ–°ï¼Œæ—§çš„å›¾æ ‡å·²è¢«åˆ é™¤ã€‚`
          : `## å›¾æ ‡æ›´æ–°

**ç‰ˆæœ¬:** ${syncRequest.version}
**è¯´æ˜:** ${syncRequest.message}
**æ¨¡å¼:** å¢é‡æ›´æ–°

æ­¤ PR ç”± Figma æ’ä»¶è‡ªåŠ¨ç”Ÿæˆã€‚

### å˜æ›´å†…å®¹
- âœ… ä¸Šä¼ /æ›´æ–°äº† ${uploadedCount} ä¸ªå›¾æ ‡`;

        const prResponse = await fetch(`https://api.github.com/repos/${repo}/pulls`, {
          method: 'POST',
          headers,
          body: JSON.stringify({
            title: prTitle,
            body: prBody,
            head: branchName,
            base: defaultBranch
          })
        });

        if (!prResponse.ok) {
          const error = await prResponse.json();
          throw new Error(`åˆ›å»º PR å¤±è´¥: ${error.message || prResponse.status}`);
        }

        const prData = await prResponse.json();
        console.log(`âœ… PR åˆ›å»ºæˆåŠŸ: #${prData.number}`);

        // 5. è‡ªåŠ¨åˆå¹¶ PR
        console.log(`ğŸ”„ æ­£åœ¨è‡ªåŠ¨åˆå¹¶ PR #${prData.number}...`);
        const mergeResponse = await fetch(`https://api.github.com/repos/${repo}/pulls/${prData.number}/merge`, {
          method: 'PUT',
          headers,
          body: JSON.stringify({
            commit_title: `ğŸ¨ ${prTitle}`,
            commit_message: `è‡ªåŠ¨åˆå¹¶å›¾æ ‡æ›´æ–°\n\nç‰ˆæœ¬: ${syncRequest.version}\n${syncRequest.message}`,
            merge_method: 'squash'  // ä½¿ç”¨ squash åˆå¹¶ä¿æŒæäº¤å†å²æ•´æ´
          })
        });

        if (!mergeResponse.ok) {
          const mergeError = await mergeResponse.json();
          console.warn(`âš ï¸ è‡ªåŠ¨åˆå¹¶å¤±è´¥: ${mergeError.message || mergeResponse.status}`);
          // åˆå¹¶å¤±è´¥ä¸å½±å“æ•´ä½“æµç¨‹ï¼ŒPR å·²åˆ›å»ºï¼Œç”¨æˆ·å¯ä»¥æ‰‹åŠ¨åˆå¹¶
        } else {
          console.log(`âœ… PR #${prData.number} å·²è‡ªåŠ¨åˆå¹¶åˆ° ${defaultBranch}`);
        }

        // 6. è§¦å‘æ„å»ºå·¥ä½œæµ
        const dispatchResponse = await fetch(`https://api.github.com/repos/${repo}/dispatches`, {
          method: 'POST',
          headers,
          body: JSON.stringify({
            event_type: 'icon_build',
            client_payload: {
              version: syncRequest.version,
              message: syncRequest.message,
              pr_number: prData.number,
              branch: branchName
            }
          })
        });

        // dispatch è¿”å› 204 è¡¨ç¤ºæˆåŠŸ
        if (dispatchResponse.status !== 204) {
          console.warn('è§¦å‘æ„å»ºå·¥ä½œæµå¤±è´¥ï¼Œä½† PR å·²åˆ›å»º');
        }

        return {
          success: true,
          prUrl: prData.html_url,
          merged: mergeResponse.ok
        };

      } catch (error) {
        return {
          success: false,
          error: error.message
        };
      }
    }

    /**
     * å°†æ–‡ä»¶åè½¬æ¢ä¸ºå®‰å…¨çš„æ ¼å¼
     * æ”¯æŒä¸­æ–‡å’Œå…¶ä»– Unicode å­—ç¬¦
     */
    function sanitizeFilename(name) {
      // ä¿ç•™ä¸­æ–‡ã€å­—æ¯ã€æ•°å­—ã€è¿å­—ç¬¦
      let result = name
        .replace(/\s+/g, '-')           // ç©ºæ ¼è½¬è¿å­—ç¬¦
        .replace(/[\/\\:*?"<>|]/g, '-') // ç§»é™¤æ–‡ä»¶ç³»ç»Ÿä¸å…è®¸çš„å­—ç¬¦
        .replace(/-+/g, '-')            // å¤šä¸ªè¿å­—ç¬¦åˆå¹¶
        .replace(/^-|-$/g, '')          // ç§»é™¤é¦–å°¾è¿å­—ç¬¦
        .trim();

      // å¦‚æœç»“æœä¸ºç©ºï¼Œä½¿ç”¨åŸå§‹åç§°çš„ hash
      if (!result) {
        result = 'icon-' + Math.random().toString(36).substring(2, 8);
      }

      return result;
    }

    /**
     * å°†å­—ç¬¦ä¸²è½¬æ¢ä¸º PascalCase
     */
    function toPascalCase(str) {
      if (!str || str.trim().length === 0) {
        return '';
      }

      const words = str
        .replace(/([a-z])([A-Z])/g, '$1 $2')
        .replace(/[-_\s]+/g, ' ')
        .trim()
        .split(/\s+/)
        .filter((word) => word.length > 0);

      return words
        .map((word) => {
          if (word.length === 0) return '';
          return word.charAt(0).toUpperCase() + word.slice(1).toLowerCase();
        })
        .join('');
    }

    /**
     * ç”Ÿæˆ React ç»„ä»¶åç§°
     */
    function generateComponentName(iconName, prefix = 'Icon') {
      const pascalName = toPascalCase(iconName);
      if (!pascalName) {
        return prefix;
      }
      return `${prefix}${pascalName}`;
    }

    // ============================================
    // UI Helpers
    // ============================================

    function showStatus(elementId, message, type) {
      const el = document.getElementById(elementId);
      el.className = `status status-${type}`;
      el.innerHTML = message;
      el.classList.remove('hidden');
    }

    function showError(message) {
      document.getElementById('progress-container').classList.add('hidden');
      showStatus('sync-status', message, 'error');
      isSyncing = false;
      updateSyncButton(false);
    }

    function updateSyncButton(loading) {
      const btn = document.getElementById('sync-btn');
      btn.disabled = loading;
      btn.innerHTML = loading
        ? '<span class="loading"></span>åŒæ­¥ä¸­...'
        : 'åŒæ­¥å›¾æ ‡åˆ° GitHub';
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ============================================
    // Initialize
    // ============================================

    postMessage('load-config');
  </script>
</body>

</html>